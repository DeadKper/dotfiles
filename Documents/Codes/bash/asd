#!/usr/bin/env -S bash

main() {
	unset DEBUG
	[[ $- == *"x"* ]] && { DEBUG=true; }

	check_dependencies ansible gpg expect sshpass ssh sftp

	debug
	parseopts \
		g=alias          -alias \
		s=store          -store \
		S=support        -support \
		c+=cmds          -cmds+ \
		x:=exec          -exec: \
		a\*=args         -args\* \
		d+=download      -download+ \
		C=clean-download -clean-download \
		D=no-tree        -no-tree \
		u+=upload        -upload+ \
		t:=target        -target \
		l:=login-name    -login-name: \
		k=ask-pass       -ask-pass \
		i:=inventory     -inventory: \
		f:=forks         -forks: \
		F=force          -force \
		z=dry-run        -dry-run \
		w:=timeout       -timeout: \
		n=print          -print \
		T=typer          -typer \
		h=help           -help \
		V=version        -version \
		-cache-only \
		-update-stores \
		-gpg-reset \
		-clean-cache \
		-edit \
		-config \
		-ansible-print \
		-uninstall \
		-- "$@"
	debug true

	if [[ "$?" != 0 ]]; then
		{
			echo
			usage
		} >&2
		exit 1
	fi

	set -- "${_ARGS[@]}"

	if [[ -z "$1" && -z "$GPG_RESET$VERSION$HELP$CLEAN_CACHE$UNINSTALL$EDIT$CONFIG$ANSIBLE_PRINT$INVENTORY" ]]; then
		help >&2
		exit 1
	fi
	REMOTE="$1"
	shift

	if test -n "$GPG_RESET"; then
		gpgconf --kill gpg-agent
		gpg-connect-agent reloadagent /bye
		exit 0
	fi
	if test -n "$VERSION"; then
		echo "$(basename "$0") version 1.4 beta"
		exit
	fi
	if test -n "$HELP"; then
		help
		exit
	fi

	config "$@"
	readarray -t updater < <(ls -1 "$BASE_DIR/saved/$STORES_UPDATER:"* 2>/dev/null)
	if test "${#updater[@]}" -gt 0 && ! valid_cache "$BASE_DIR/stores.txt" "$STORES_AUTOUPDATE"; then
		update_stores
	fi
	if test -n "$RUN"; then
		set -- "$RUN" "$@"
	fi
	if test -n "$CLEAN_CACHE"; then
		rm -rf "$BASE_DIR/saved/$LOGIN_NAME@"*
		exit 0
	fi
	if test -n "$UNINSTALL"; then
		rm -rf "$BASE_DIR" "$TEMP_DIR"
		exit 0
	fi
	if test -n "$EDIT"; then
		vault_edit "$BASE_DIR/credentials/$LOGIN_NAME"
		exit 0
	fi

	test -n "$TYPER" -a -z "$*" && error "$SCRIPT: error: cannot use typer without executable to type into"

	make_ansible_config

	test -n "$CONFIG" -o -n "$ANSIBLE_PRINT" && exit 0

	if test -n "$INVENTORY"; then
		test -z "$TYPER" || error "$SCRIPT: error: cannot use --typer with -i"
		if test -n "$REMOTE"; then
			error "$SCRIPT: error: only optional argument inventory or positional argument remote is needed, using both is not supported"
		fi
		if test -z "${DRY_RUN}${CMDS}${EXEC}${DOWNLOAD}${UPLOAD}"; then
			error "$SCRIPT: error: flag -i needs one of the following flags -z, -c, -x, -d, -u"
		fi
	fi

	if test -n "$INVENTORY"; then
		if test -n "$ASK_PASS"; then
			read -s -p 'Password: ' PASSWORDS; echo
		else
			readarray -t PASSWORDS < <(vault_view "$BASE_DIR/credentials/$LOGIN_NAME" | grep '\S')
		fi
		test -f "$BASE_DIR/credentials/$LOGIN_NAME" || exit 1
		local pad="$(printf '%s\n' "${INVENTORY[@]}" | awk '{print length}' | sort -gru | head -1)"
		test "$pad" -ge 15 2>/dev/null || local pad=15
		mkdir -p "$TEMP_DIR/logs/$DATE"
		trap "disown $$; kill -s kill $$" exit int hup term kill
		test -n "$DRY_RUN" || echo 'Validating remotes...' | color cyan
		for remote in "${INVENTORY[@]}"; do
			iwait -t jobs -a $FORKS $$
			inventory_check "$remote" "$pad" 2> >(color red >&2) | color green &
		done
		wait
		sleep 0.5
		if test -n "$DRY_RUN"; then
			trap - exit int hup term kill
			exit 0
		fi
		echo "Remotes validated" | color cyan
		CACHE_ONLY=true
		local log_output="$(test -n "${DRY_RUN}${CMDS}${EXEC}" && echo yes)"
		readarray -t validated < <(sort -V < "$TEMP_DIR/logs/$DATE/validated")
		local print
		local printed=0
		for remote in "${validated[@]}"; do
			iwait -t jobs -a $FORKS $$
			if test -n "$log_output"; then
				test -f "$TEMP_DIR/logs/$DATE/done" && readarray -t print < "$TEMP_DIR/logs/$DATE/done" || print=()
				if test ${#print[@]} -gt $printed; then
					for i in $(seq $printed 1 $((${#print[@]}-1))); do
						cat "$TEMP_DIR/logs/$DATE/${print[$i]}.log" | xargs -d '\n' -n 1 -r echo -e "$(prefix "$pad" "${print[$i]}" true)"
					done
					printed=${#print[@]}
				fi
				{
					connect "$LOGIN_NAME" "$remote" "$@" 2>&1 > "$TEMP_DIR/logs/$DATE/$remote.log"
					echo "$remote" >> "$TEMP_DIR/logs/$DATE/done"
				} &
			else
				connect "$LOGIN_NAME" "$remote" "$@"
			fi
		done
		if test -n "$log_output"; then
			debug
			while test ${#print[@]} -lt "${#validated[@]}"; do
				test -f "$TEMP_DIR/logs/$DATE/done" && readarray -t print < "$TEMP_DIR/logs/$DATE/done" || print=()
				if test ${#print[@]} -gt $printed; then
					debug true
					for i in $(seq $printed 1 $((${#print[@]}-1))); do
						cat "$TEMP_DIR/logs/$DATE/${print[$i]}.log" | xargs -d '\n' -n 1 -r echo -e "$(prefix "$pad" "${print[$i]}" true)"
					done
					printed=${#print[@]}
					debug
				fi
				sleep 0.1
			done
			debug true
		fi
		wait
		trap - exit int hup term kill
		test -n "$log_output" || exit 0
		divisor="==============================================="
		for remote in "${validated[@]}"; do
			cat "$TEMP_DIR/logs/$DATE/$remote.log" 2>&1 | xargs -d '\n' -n 1 -r echo "$(prefix "$pad" "$remote")" >> "$TEMP_DIR/logs/$DATE/output.log"
			echo "$divisor [[ $(center "$pad" "$remote") ]] $divisor" >> "$TEMP_DIR/logs/$DATE/replay.log"
			cat "$TEMP_DIR/logs/$DATE/$remote.log" >> "$TEMP_DIR/logs/$DATE/replay.log"
		done
		readarray -t errored < <(printf '%s\n' "${INVENTORY[@]}" "${validated[@]}" | sort -V | uniq -c | grep '^\s*1\s' | awk '{print $2}')
		if test "${#errored[@]}" -gt 0; then
			echo "$divisor [[ $(center "$pad" "ERRORS") ]] $divisor" >> "$TEMP_DIR/logs/$DATE/replay.log"
			for remote in "${errored[@]}"; do
				cat "$TEMP_DIR/logs/$DATE/$remote.log" | xargs -d '\n' -n 1 -r echo "$(prefix "$pad" "$remote")" | tee -a "$TEMP_DIR/logs/$DATE/replay.log" >> "$TEMP_DIR/logs/$DATE/output.log"
			done
		fi
		echo "log: '$TEMP_DIR/logs/$DATE/replay.log'" | color cyan
	else
		connect "$LOGIN_NAME" "$REMOTE" "$@"
	fi
}

usage() {
	cat <<EOF
usage: asd [-g] [-s] [-S] [-c COMMANDS [COMMANDS...]] [-x SCRIPT] [-a [ARGUMENTS...]] [-d FILES [FILES...]] [-C] [-D] [-u FILES [FILES...]] [-t DIRECTORY] [-l USERNAME] [-k] [-i INVENTORY] [-f FORKS] [-F] [-z] [-w ARG] [-n] [-T] [-h] [-V] [--cache-only] [--update-stores] [--gpg-reset] [--clean-cache] [--edit] [--config] [--ansible-print] [--uninstall] remote
EOF
}

help() {
	usage
	cat <<EOF

options:
  -g, --alias                        treat remote as a alias
  -s, --store                        treat remote as a store number
  -S, --support                      treat remote as a support store number
  -c, --cmds COMMANDS [COMMANDS...]  commands to execute on remote
  -x, --exec SCRIPT                  script to execute on remote
  -a, --args [ARGUMENTS...]          args to pass on to the script
  -d, --download FILES [FILES...]    files to download from remote (defaults to ~/Download/\$REMOTE)
  -C, --clean-download               clean download folder before downloading
  -D, --no-tree                      try to reduce tree scructure as much as possible when downloading
  -u, --upload FILES [FILES...]      files to upload to the remote (defaults to /sysx/src)
  -t, --target DIRECTORY             target folder for uploads or downloads from remote
  -l, --login-name USERNAME          login name to use for the ssh connection
  -k, --ask-pass                     ask for login password
  -i, --inventory INVENTORY          ansible inventory or comma separated list of hosts
  -f, --forks FORKS                  ammount of forks to use
  -F, --force                        ignore cached password and test login data
  -z, --dry-run                      don't connect, just test connection
  -w, --timeout TIMEOUT              ammount of time to wait for ssh banner before connection drops
  -n, --print                        print password to stdout
  -T, --typer                        use this script as a password typer, incompatible with -i
  -h, --help                         print help text and exit
  -V, --version                      print version number and exit
  --cache-only                       always use cached password
  --update-stores                    update stores file and exit
  --gpg-reset                        reset gpg daemon and exit
  --clean-cache                      clean login cache and exit
  --edit                             edit current user vault and exit
  --config                           make configuration and exit
  --ansible-print                    print recommended ansible configuration and exit
  --uninstall                        remove all folders created by this script and exit
EOF
}

connect() {
	local user="$1"
	local remote="$2"
	shift 2
	if test -z "$CACHE_ONLY"; then
		check_cache "$user" "$remote"
	elif test ! -f "$BASE_DIR/saved/$user@$remote:22"; then
		return 1
	fi
	test -f "$BASE_DIR/saved/$user@$remote:22" || exit 1
	local passwd="$(vault_view "$BASE_DIR/saved/$user@$remote:22" | grep '\S')"
	if test -z "$passwd"; then
		exit 1
	fi
	if test -n "$DRY_RUN"; then
		if test -n "$CACHED_PASSWORD" -a -z "$CACHE_ONLY"; then
			out="$(typer sshpass "$passwd" ssh -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" "$user@$remote" -T 'echo authenticated' 2>&1)"
			grep -q "^authenticated\s*$" <<< "$out" || error "error: $out"
		fi
		local msg=authenticated
		if test -n "$PRINT"; then
			msg="$msg: $passwd"
			unset PRINT
		fi
		echo $msg | color green
		exit 0
	elif test -n "$PRINT"; then
		echo "$passwd"
		unset PRINT
	fi
	local sudo=""
	if grep -qwF 'sudo' <<< "$LOGIN_CMD"; then
		sudo=sudo
	fi
	if test -n "$LOGIN_CMD"; then
		local login=(-t "$LOGIN_CMD")
	fi
	if test -n "$TYPER"; then
		typer expect "$passwd" "$@"
	elif test -n "$CMDS"; then
		typer sshpass "$passwd" ssh -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" "$user@$remote" -T "$sudo bash -s $(printf "'%s' " "${ARGS[@]}")" < <(echo "${CMDS[@]}")
	elif test -n "$EXEC"; then
		typer sshpass "$passwd" ssh -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" "$user@$remote" -T "$sudo bash -s $(printf "'%s' " "${ARGS[@]}")" < "$EXEC"
	elif test -n "$DOWNLOAD"; then
		download "$passwd" "$user" "$remote" "$sudo"
	elif test -n "$UPLOAD"; then
		upload "$passwd" "$user" "$remote" "$sudo"
	else
		typer sshpass "$passwd" ssh -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" "$user@$remote" "${login[@]}"
	fi
}

download() {
	local passwd="$1"
	local user="$2"
	local remote="$3"
	local sudo="$4"
	if test -z "$TARGET"; then
		TARGET="$dir/$remote"
		if test -d ~/Descargas; then
			TARGET=~/Descargas
		else
			TARGET=~/Downloads
		fi
		local autodir=true
	fi
	if test -n "$INVENTORY" -o "$autodir"; then
		local directory="$TARGET/$remote"
	else
		local directory="$TARGET"
	fi
	if test -n "$CLEAN_DOWNLOAD"; then
		if test -d "$directory"; then
			rm -rf "$directory"
		elif test -e "$directory"; then
			error "target '$directory' exists but it's not a directory"
		fi
	fi
	mkdir -p "$directory"
	local sftp_cmds=("@progress")
	for download in "${DOWNLOAD[@]}"; do
		dir="$directory/$(dirname "$download")"
		mkdir -p "$dir"
		sftp_cmds+=("@get -r '$download' '$dir/'")
	done
	sftp_cmds+=("@bye")
	sftp_args=()
	if test -n "$sudo"; then
		sftp_args=(-s 'sudo -u root /usr/libexec/openssh/sftp-server')
	fi
	typer expect "$passwd" sftp -C "${sftp_args[@]}" -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" -b <(printf '%s\n' "${sftp_cmds[@]}") "$user@$remote"
	if test -n "$NO_TREE"; then
		readarray -t dirs < <(find "$directory" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
		while test ${#dirs[@]} -eq 1; do
			tmp="$dirs.TMP$(LC_ALL=C tr -dc A-Za-z0-9 </dev/urandom | head -c 10)"
			mv "$directory/$dirs" "$directory/$tmp"
			mv "$directory/$tmp/"{.*,*} "$directory" 2>/dev/null
			rmdir "$directory/$tmp" || error "could not clean directory tree structure"
			readarray -t dirs < <(find "$directory" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
		done
	fi
}

upload() {
	local passwd="$1"
	local user="$2"
	local remote="$3"
	local sudo="$4"
	if test -z "$TARGET"; then
		TARGET="/sysx/src"
		typer sshpass "$passwd" ssh -q "${sftp_args[@]}" -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" "$user@$remote" -T "sudo mkdir -p '$TARGET'"
	fi
	if grep -q '/$' <<< "$TARGET"; then
		local target_path="$TARGET"
	else
		local target_path="$(dirname "$TARGET")"
	fi
	sftp_cmds=(
		"@progress"
		"@cd '$TARGET'"
	)
	for file in "${UPLOAD[@]}"; do
		test -e "$file" || error "given path '$file' doesn't exists"
		sftp_cmds+=("@put -r '$file'")
	done
	sftp_cmds+=("@bye")

	if test -n "$sudo"; then
		sftp_args=(-s 'sudo -u root /usr/libexec/openssh/sftp-server')
	fi
	typer expect "$passwd" sftp -C "${sftp_args[@]}" -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" -b <(printf '%s\n' "${sftp_cmds[@]}") "$user@$remote"
}

update_stores() {
	readarray -t updater < <(ls -1 "$BASE_DIR/saved/$STORES_UPDATER:"* 2>/dev/null)
	if test "${#updater[@]}" -eq 0; then
		error "$SCRIPT: error: stores updater connection not configured"
	fi
	local user="$(cut -d@ -f1 <<< "$STORES_UPDATER")"
	local ip="$(cut -d@ -f2 <<< "$STORES_UPDATER")"
	local passwd="$(vault_view "${updater[0]}" | grep '\S')"
	if test -z "$passwd"; then
		exit 1
	fi
	echo 'updating stores.txt file...' | color cyan
	typer sshpass "$passwd" sftp -C -q "${SSH_ARGS[@]}" -b <(printf '%s\n' "@get '$STORES_PATH' '$BASE_DIR/stores.txt'" "@bye") "$STORES_UPDATER"
	local code="$?"
	test "$code" = 0 || exit "$code"
	test -z "$UPDATE_STORES" || exit "$code"
	touch -m "$BASE_DIR/stores.txt"
	return "$code"
}

set_store_ip() {
	if ! test -f "$BASE_DIR/stores.txt"; then
		error "stores file not found in path: '$BASE_DIR/stores.txt'"
	fi

	local ip="$(awk "/^0*$REMOTE .* ${STORE+PPAL}${SUPPORT+SOP}\$/ {print \$2}" "$BASE_DIR/stores.txt")"

	if ! grep -qE '^10(\.[0-9]+){3}$' <<< "$ip"; then
		error "$SCRIPT: error: valid store ip for '$REMOTE' not found"
	fi

	OLD_REMOTE="$REMOTE"
	REMOTE="$ip"
}

config() {
	SCRIPT="$(basename "$0")"
	TEMP_DIR=~/.cache/${SCRIPT}
	BASE_DIR=~/.local/share/${SCRIPT}
	VAULT_SH=~/.ansible/vaultpass.sh
	VAULT_FILE=~/.ansible/passphrase
	CONFIG_SH=~/.config/${SCRIPT}.sh
	DATE="$(date +%Y-%m-%dT%H:%M:%S.%3N%z)"
	DEFAULT_CONFIG="
DEFAULT_USER=sysadmin                           # default user
PROMPTS=('ALL=3')                               # default number of prompts to use for password detection
LOGIN_CMD=('ALL=\$SHELL -l')                     # login command when using normal connection
CACHE_EXPIRE_TIME=604800                        # defaults to 1 week in seconds; leave empty to always use cache, or 0 to always try passwords
STORES_UPDATER=linux@10.28.137.133              # connection string to stores updater
STORES_AUTOUPDATE=                              # defaults to disabled; ammount in seconds before refreshing stores file
STORES_PATH=/home/linux/.local/state/ssh/stores # file path in stores updater
SSH_ARGS=(                                      # list of arguments to use by default
	-o BatchMode=no
	-o ConnectTimeout=10
	-o LogLevel=ERROR
	-o CheckHostIP=no
	-o StrictHostKeyChecking=no
	-o UserKnownHostsFile=/dev/null
	-o PreferredAuthentications=password
)
"
	local ansible_cfg=""
	if test -f ./ansible.cfg; then
		ansible_cfg=./ansible.cfg
	elif test -f ./.ansible.cfg; then
		ansible_cfg=./.ansible.cfg
	elif test -f ~/.ansible.cfg; then
		ansible_cfg=~/.ansible.cfg
	elif test -f ~/ansible.cfg; then
		ansible_cfg=~/ansible.cfg
	elif test -f /etc/ansible/ansible.cfg; then
		ansible_cfg=/etc/ansible/ansible.cfg
	else
		ansible_cfg="$(ansible --version 2>/dev/null | grep '^\s*config file\s*=' | sed -E 's/^[^=]+=\s*//')"
		if test -z "$ansible_cfg"; then
			cat <<EOF >&2
utils error: missing ansible.cfg

$ansible_recommended
EOF
			exit 1
		fi
	fi

	if test -z "$FORKS"; then
		if test -n "$ANSIBLE_FORKS"; then
			FORKS=$ANSIBLE_FORKS
		else
			forks=$(cat "$ansible_cfg" | grep '^\s*forks\s*=' | sed 's/^\s*forks\s*=\s*//')
			if test -n "$forks"; then
				FORKS=$forks
			else
				FORKS=5
			fi
		fi
	fi

	test -f "$CONFIG_SH" || echo "$DEFAULT_CONFIG" | sed -zE 's/^\n|\n$//' >"$CONFIG_SH"
	source <(echo "$DEFAULT_CONFIG")
	source "$CONFIG_SH"
	if test -n "$TIMEOUT"; then
		SSH_ARGS=(
			-o ConnectTimeout="$TIMEOUT"
			"${SSH_ARGS[@]}"
		)
	fi
	if test -n "$UPDATE_STORES"; then
		update_stores
	fi
	if grep -q '@' <<< "$REMOTE"; then
		LOGIN_NAME="$(cut -d@ -f1 <<< "$REMOTE")"
		REMOTE="$(cut -d@ -f2 <<< "$REMOTE")"
	fi
	test $(wc -c <<< "${STORE+x}${SUPPORT+x}${INVENTORY+x}${ALIAS+x}") -gt 2 && error "$SCRIPT: error: usage of incompatible flags (-s, -S, -i, -g)"
	if test -n "$ALIAS" -a -f "$BASE_DIR/alias.txt"; then
		remote="$(grep -wF "$REMOTE" "$BASE_DIR/alias.txt" | awk '{print $1}')"
		test -z "$remote" && error "$SCRIPT: error: unknown alias '$REMOTE'"
		REMOTE="$remote"
	elif test -n "$STORE$SUPPORT"; then
		set_store_ip
	fi
	if test -z "$LOGIN_NAME"; then
		if test -n "$REMOTE"; then
			readarray -t found < <(ls "$BASE_DIR/saved/"*"@$REMOTE:"* -1 2>/dev/null)
			if test "${#found[@]}" -gt 1; then
				grep -q "^$DEFAULT_USER@" < <(printf '%s\n' "${found[@]}") && LOGIN_NAME="$DEFAULT_USER"
			fi
			test -n "$LOGIN_NAME" || LOGIN_NAME="$(basename "${found[0]}" | sed 's/@.*//')"
		fi
		test -n "$LOGIN_NAME" || LOGIN_NAME="$DEFAULT_USER"
	fi
	local username_regex="^$(sed -E 's/([^a-zA-Z0-9 _\-])/[\1]/g' <<< "$LOGIN_NAME")="
	local prompt_ammount="$(printf '%s\n' "${PROMPTS[@]}" | grep -E "$username_regex" | sed 's/^[^=]*=//')"
	if test -n "$prompt_ammount"; then
		PROMPTS=$prompt_ammount
	else
		local prompt_ammount="$(printf '%s\n' "${PROMPTS[@]}" | grep -E "^ALL=" | sed 's/^[^=]*=//')"
		if test -n "$prompt_ammount"; then
			PROMPTS=$prompt_ammount
		else
			PROMPTS=3
		fi
	fi
	local login_command="$(printf '%s\n' "${LOGIN_CMD[@]}" | grep -E "$username_regex" | sed 's/^[^=]*=//')"
	if test -n "$login_command"; then
		LOGIN_CMD=$login_command
	else
		local login_command="$(printf '%s\n' "${LOGIN_CMD[@]}" | grep -E "^ALL=" | sed 's/^[^=]*=//')"
		if test -n "$login_command"; then
			LOGIN_CMD=$login_command
		else
			LOGIN_CMD=''
		fi
	fi
	for dir in ~/.ansible "$BASE_DIR/credentials" "$BASE_DIR/saved" "$BASE_DIR/ansible" "$TEMP_DIR/logs" "$TEMP_DIR/tmp"; do
		if test ! -d "$dir"; then
			test ! -f "$dir" || error "$SCRIPT: error: reserved dir is actually a file ($dir)"
			mkdir -p "$dir" || error "$SCRIPT: error: reserved dir could not be created ($dir)"
		fi
	done
	if test -n "$CONFIG"; then
		cat <<EOF
# ~/.ssh/config
Host 10.* *coppel* !10.26.21.* !10.28.137.*
	LogLevel ERROR
	CheckHostIP no
	StrictHostKeyChecking no
	UserKnownHostsFile /dev/null
EOF
	fi
	if test -n "$CONFIG" -o -n "$ANSIBLE_PRINT" -o -n "$CACHE_ONLY" -o -n "$UNINSTALL" -o -n "$EDIT" -o -n "$CLEAN_CACHE"; then
		return 0
	fi
	if which "$REMOTE" &>/dev/null && test -n "$TYPER"; then
		readarray -t remotes < <(printf '%s\n' "$@" | grep -iE '^[a-z0-9]+@[a-z0-9.]+' | sed 's/:.*//g' | sort -u)
		if test "${#remotes[@]}" -eq 0; then
			error "$SCRIPT: error: cannot detect remote automatically"
		fi
		if test "${#remotes[@]}" -gt 1; then
			error "$SCRIPT: error: too many remotes were detected, cannot identify correct one"
		fi
		RUN="$REMOTE"
		REMOTE="$(sed -E 's/^[^@]+@//' <<< "$remotes")"
	else
		unset RUN
	fi
	test -z "$CACHE_ONLY" || return 0
	if test -n "$INVENTORY"; then
		if grep -q , <<< "$INVENTORY"; then
			readarray -t INVENTORY < <(sed 's/,/\n/g' <<< "$INVENTORY" | grep '\S' | sort -uV)
		else
			test -f "$INVENTORY" || error "$SCRIPT: error: file '$INVENTORY' doesn't exists"
			readarray -t INVENTORY < <(grep -vE '^\s*#|^\s*;' < "$INVENTORY" | grep '\S' | sed -zE 's/(^|\n)[[][^:\n]+:[^]\n]+[]][^[]+/\n/g' | grep -v '^\[' | awk '{print $1}' | sort -uV)
		fi
		local invalid=()
		for ip in "${INVENTORY[@]}"; do
			check_server "$ip" || invalid+=("$ip")
		done
		if test "${#invalid[@]}" -gt 0; then
			error "$SCRIPT: error: invalid ips were given ($(printf "'%s' " "${invalid[@]}" | sed 's/ $//'))"
		fi
	else
		if test -n "$__PARSER_ERROR"; then
			echo 1 | __parser_print_help "${cli_args[@]}"
			echo "$__PARSER_ERROR" >&2
			exit $__PARSER_ERROR_CODE
		fi
		check_server "$REMOTE" || error "$SCRIPT: error: invalid ips were given ('$REMOTE')"
	fi
}

prefix() {
	if test -n "$3"; then
		printf "\e[0;32m%-${1}s \e[0;35m->\e[0m" "$2"
	else
		printf "%-${1}s ->" "$2"
	fi
}

inventory_check() {
	local remote="$1"
	local pad="$2"
	shift 2
	check_cache "$LOGIN_NAME" "$remote" 2> >(xargs -r echo "error:" | tee "$TEMP_DIR/logs/$DATE/$remote.log" | xargs -r -d '\n' -n 1 echo "$(prefix "$pad" "$remote")" >&2) || return 1
	test -f "$BASE_DIR/saved/$LOGIN_NAME@$remote:22" || return 1
	if test -z "$ASK_PASS"; then
		local passwd="$(vault_view "$BASE_DIR/saved/$LOGIN_NAME@$remote:22" | grep '\S')"
	else
		local passwd="$PASSWORDS"
	fi
	out="$(typer sshpass "$passwd" ssh -o NumberOfPasswordPrompts=1 "${SSH_ARGS[@]}" "$LOGIN_NAME@$remote" -T 'echo authenticated' 2>&1)"
	if ! grep -q "^authenticated\s*$" <<< "$out"; then
		echo "error: $out" | tee "$TEMP_DIR/logs/$DATE/$remote.log" | xargs -r -d '\n' -n 1 echo "$(prefix "$pad" "$remote")" >&2
		return 1
	fi
	if test -n "$PRINT"; then
		echo "$(test -n "$DRY_RUN" && echo 'authenticated: ' || echo '')$passwd" | tee "$TEMP_DIR/logs/$DATE/$remote.log" | xargs -r -d '\n' -n 1 echo "$(prefix "$pad" "$remote")"
	else
		test -z "$DRY_RUN" || echo "authenticated" | tee "$TEMP_DIR/logs/$DATE/$remote.log" | xargs -r -d '\n' -n 1 echo "$(prefix "$pad" "$remote")"
	fi
	echo "$remote" >> "$TEMP_DIR/logs/$DATE/validated"
}

check_cache() {
	local user="$1"
	local remote="$2"
	if test -n "$ASK_PASS"; then
		read -s -p 'Password: ' passwd; echo
		test_passwords "$user" "$remote" "$passwd"
	elif valid_cache "$BASE_DIR/saved/$user@$remote:22" "$CACHE_EXPIRE_TIME" && test -z "$FORCE"; then
		CACHED_PASSWORD=true
	else
		unset CACHED_PASSWORD
		test -n "$INVENTORY" || readarray -t PASSWORDS < <(vault_view "$BASE_DIR/credentials/$user" | grep '\S')
		test -f "$BASE_DIR/credentials/$user" || exit 1
		test_passwords "$user" "$remote" "${PASSWORDS[@]}"
	fi
}

check_server() {
	local ip="$1"

	if test -z "$ip"; then
		return 1
	fi
	if grep -qE '^[0-9.]+$' <<< "$ip"; then
		if ! grep -qE '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$' <<< "$ip"; then
			return 1
		fi
	fi
}

valid_cache() {
	local file="$1"
	local expire="$2"
	grep -qE '^[0-9]+$' <<< "$expire" || return 0
	if test -f "$file"; then
		mod_date=$(stat -c %Y "$file")
		cur_date=$(date +%s)
		test $((cur_date - mod_date)) -le $expire && return 0
	fi
	return 1
}

test_passwords() {
	local user="$1"
	local remote="$2"
	local connection="$user@$remote:22"
	shift 2
	if test -f "$BASE_DIR/saved/$connection"; then
		local unique=true
		local curr_pass="$(vault_view "$BASE_DIR/saved/$connection" | grep '\S')"
		for pass in "$@"; do
			if test "$pass" = "$curr_pass"; then
				unique=""
				break
			fi
		done
		if test "$unique" = true; then
			local passwords=("$curr_pass" "$@")
		fi
	fi
	if test -z "$passwords"; then
		local passwords=("$@")
	fi
	local pass_len=${#passwords[@]}
	rm -f "$TEMP_DIR/tmp/$connection"{.out,.err} 2>/dev/null
	local thread_count=$(((pass_len+PROMPTS-1)/PROMPTS))
	local threads=()
	trap "rm -f $(printf "'%s' " "$TEMP_DIR/tmp/$connection"{.out,.err}) 2>/dev/null" kill int exit term
	for thread in $(seq 0 1 $((thread_count-1))); do
		tester_thread "$user" "$remote" $thread "$TEMP_DIR/tmp/$connection" "${passwords[@]:$((thread*PROMPTS)):$(((thread+1)*PROMPTS))}" &
		threads+=("$!")
		test "${#threads[@]}" -lt "$thread_count" && sleep 0.25
	done
	debug
	while test ! -f "$TEMP_DIR/tmp/${connection}.out" && ps -p "${threads[@]}" &>/dev/null; do
		sleep 0.1
	done
	debug true
	disown "${threads[@]}" &>/dev/null
	kill -s kill "${threads[@]}" &>/dev/null
	sleep 0.1
	ps -p "${threads[@]}" &>/dev/null && error "could not kill tester jobs (${threads[@]})"
	if test -f "$TEMP_DIR/tmp/${connection}.out"; then
		sleep 0.25
		mv "$TEMP_DIR/tmp/${connection}.out" "$BASE_DIR/saved/$connection"
		rm -f "$TEMP_DIR/tmp/$connection"{.out,.err} 2>/dev/null
		trap - kill int exit term
	else
		error="$(sed -z 's/\nsend:.*//' < "$TEMP_DIR/tmp/${connection}.err" | tail -2)"
		if grep -qwF '"send -- "[lindex' <<< "$error"; then
			if test -f "$TEMP_DIR/tmp/${connection}.out"; then
				error="$(sed -z 's/\nsend:.*//' < "$TEMP_DIR/tmp/${connection}.out")"
			else
				error="Connection timed out during banner exchange"
			fi
		fi
		rm -f "$TEMP_DIR/tmp/$connection"{.out,.err} 2>/dev/null
		trap - kill int exit term
		if test -n "$INVENTORY"; then
			echo "$error" >&2
			return 1
		else
			error "$error"
		fi
	fi
}

tester_thread() {
	local user="$1"
	local remote="$2"
	local thread="$3"
	local output="$4"
	shift 4
	local passwd_count="$#"
	local auth='authenticated'
	local prefix='password:'
	local SSH_TEST_ARGS=(
		-o NumberOfPasswordPrompts=$((passwd_count+1))
		-o StrictHostKeyChecking=no
		-o UserKnownHostsFile=/dev/null
	)

	out="$(expect <(cat <<EOF
set timeout -1
set index 0

spawn -noecho ssh ${SSH_TEST_ARGS[@]} ${SSH_ARGS[@]} $user@$remote -T "echo $auth"
expect "assword:"
send -- "[lindex \$argv \$index]\r"
expect {
    "Permission denied, please try again." {
        if {\$index == [llength \$argv]} {
            error "No password found"
        }
        expect "assword:"
        incr index
        send -- "[lindex \$argv \$index]\r"
        exp_continue
    }
}
send_user "$prefix [lindex \$argv \$index]\n"
EOF
) "$@" 2>&1)"
	if echo "$out" | grep -qwF "$auth"; then
		tail -1 <<< "$out" | sed "s/^$prefix\s*//" | ansible-vault encrypt_string | tail -n +2 | sed -E 's/^\s+//' > "${output}.out"
	elif test "$thread" = 0; then
		if echo "$out" | head -1 | grep -q '^"send'; then
			echo "$user@$remote: ssh connection refused port 22" > "${output}.err"
		else
			echo "$out" | grep -v "$prefix" > "${output}.err"
		fi
	fi
}

typer() {
	local typer="$1"
	local passwd="$2"
	shift 2

	case "$typer" in
		sshpass)
			env SSHPASS="$passwd" sshpass -e "$@"
			return $?
			;;
		expect)
			expect <(cat <<EOF
set timeout -1
eval spawn -noecho \$argv
expect {
	"Are you sure you want to continue connecting" {
		send -- "yes\r"
		expect "assword:" {
			send -- "$passwd\r"
		}
	}
	"assword:" {
		send -- "$passwd\r"
	}
}
interact
catch wait result
exit [lindex \$result 3]
EOF
) "$@"
			return $?
			;;
		*)
			error "$SCRIPT: error: invalid autotyper '$typer'"
			;;
	esac
}

# UTILS SECTION
color() {
	debug
	local black='\e[0;30m'
	local red='\e[0;31m'
	local green='\e[0;32m'
	local orange='\e[0;33m'
	local blue='\e[0;34m'
	local purple='\e[0;35m'
	local cyan='\e[0;36m'
	local light_gray='\e[0;37m'
	local dark_gray='\e[1;30m'
	local light_red='\e[1;31m'
	local light_green='\e[1;32m'
	local yellow='\e[1;33m'
	local light_blue='\e[1;34m'
	local light_purple='\e[1;35m'
	local light_cyan='\e[1;36m'
	local white='\e[1;37m'
	debug true
	[ -t 1 ] && xargs -r -d \\n printf "$(eval echo "\$${1}")%s\e[0m\n" || xargs -r -d \\n -n 1 echo
}

error() {
	{ [ -t 1 ] && echo "$@" | color red || echo "$@"; } >&2
	exit 1
}

errorf() {
	{ [ -t 1 ] && cat - | color red || cat -; } >&2
	exit 1
}

errorln() {
	{ [ -t 1 ] && printf '%s\n' "$@" | color red || printf '%s\n' "$@"; } >&2
	exit 1
}

debug() {
	[[ -n "$DEBUG" ]] || return 0
	if [[ -n "$1" ]]; then
		[[ $- == *"x"* ]] || set -x
	else
		[[ $- != *"x"* ]] || set +x
	fi
}

iwait() {
	debug
	parseopts \
		t:=wait-type -type:=wait-type \
		w:=wait-timeout -timeout:=wait-timeout \
		a:=wait-arg -arg:=wait-arg \
		-- "$@"
	local args=("${_ARGS[@]}")
	local start="$(date +%s)"
	local WAIT_ARG=$((WAIT_ARG+1))

	if [[ -z "$1" ]]; then
		error wait needs an argument
	fi

	export WAIT_TIMEOUT WAIT_TYPE WAIT_ARG args start

	case "$WAIT_TYPE" in
		"")
			sleep "$1"
			;;
		jobs)
			(
				while [[ "$(pgrep -P "${args[0]}" | wc -l)" -ge "$WAIT_ARG" ]]; do
					[[ "$WAIT_TIMEOUT" -gt 0 && "$(($(date +%s)-start))" -ge "$WAIT_TIMEOUT" ]] && break
					sleep 0.1
				done
			)
			;;
		file)
			(
				while [[ ! -f "${args[0]}" ]]; do
					[[ "$WAIT_TIMEOUT" -gt 0 && "$(($(date +%s)-start))" -ge "$WAIT_TIMEOUT" ]] && break
					sleep 0.1
				done
			)
			;;
		*)
			error invalid type "$WAIT_TYPE"
			;;
	esac

	debug true
	[[ "$WAIT_TIMEOUT" -gt 0 && "$(($(date +%s)-start))" -ge "$WAIT_TIMEOUT" ]] && return 1
	return 0
}

center() {
	debug
	local pad="$1"
	shift 1
	local cent="$*"
	local flag=0
	while test "$(wc -c <<< "$cent")" -lt "$pad"; do
		if test "$flag" = 0; then
			flag=1
			cent=" $cent"
		else
			flag=0
			cent="$cent "
		fi
	done
	debug true
	echo "$cent"
}

check_dependencies() {
	local failed=""
	for cmd in "$@"; do
		if ! which "$cmd" &>/dev/null; then
			echo "command '$cmd' not found" >&2
			failed=true
		fi
	done
	if test -n "$failed"; then
		exit 1
	fi
}

set_editor() {
	if test -z "$EDITOR"; then
		if which nvim >/dev/null 2>&1; then
			EDITOR=nvim
		elif which vim >/dev/null 2>&1; then
			EDITOR=vim
		elif which nano >/dev/null 2>&1; then
			EDITOR=nano
		elif which emacs >/dev/null 2>&1; then
			EDITOR=emacs
		elif which hx >/dev/null 2>&1; then
			EDITOR=hx
		elif which vi >/dev/null 2>&1; then
			EDITOR=vi
		else
			error 'utils error: no editor detected, manually set EDITOR env variable with a valid command line editor'
		fi
	fi
}

vault_edit() {
	file="$1"
	if test -f "$file"; then
		ansible-vault edit "$file"
	else
		ansible-vault create "$file"
	fi
	if test -z "$(ansible-vault view "$file")"; then
		rm "$file"
	fi
}

vault_view() {
	file="$1"
	if test -f "$file"; then
		ansible-vault view "$file" || exit 1
	else
		error "utils error: file doesn't exists '$file'"
	fi
}

make_ansible_config() {
	local should_exit=""

	if test ! -d ~/.gnupg; then
		install -m 700 -d ~/.gnupg
	fi

	if test ! -f ~/.gnupg/gpg.conf; then
		cat <<EOF >~/.gnupg/gpg.conf
use-agent
cipher-algo aes256
EOF
	fi

	if test ! -f ~/.gnupg/gpg-agent.conf; then
		cat <<EOF >~/.gnupg/gpg-agent.conf
default-cache-ttl 43200
max-cache-ttl 43200
EOF
	fi

	local ansible_recommended="# ~/.ansible.cfg
[defaults]
become_password_file=$(sed "s,^$HOME,~," <<< "$BASE_DIR/ansible/becomepass.sh")
connection_password_file=$(sed "s,^$HOME,~," <<< "$BASE_DIR/ansible/connectionpass.sh")
vault_password_file=~/.ansible/vaultpass.sh"

	local ansible_cfg=""
	if test -f ./ansible.cfg; then
		ansible_cfg=./ansible.cfg
	elif test -f ./.ansible.cfg; then
		ansible_cfg=./.ansible.cfg
	elif test -f ~/.ansible.cfg; then
		ansible_cfg=~/.ansible.cfg
	elif test -f ~/ansible.cfg; then
		ansible_cfg=~/ansible.cfg
	elif test -f /etc/ansible/ansible.cfg; then
		ansible_cfg=/etc/ansible/ansible.cfg
	else
		ansible_cfg="$(ansible --version 2>/dev/null | grep '^\s*config file\s*=' | sed -E 's/^[^=]+=\s*//')"
		if test -z "$ansible_cfg"; then
			cat <<EOF >&2
utils error: missing ansible.cfg

$ansible_recommended
EOF
			exit 1
		fi
	fi

	local ansible_pass_files=""
	readarray -t ansible_pass_files < <(grep -E '^\s*(vault|connection|become)_password_file\s*=' "$ansible_cfg")

	if test "${#ansible_pass_files[@]}" -ne 3; then
		cat <<EOF >&2
utils error: missing ansible.cfg configuration

$ansible_recommended
EOF
		exit 1
	fi

	if test -n "$ANSIBLE_PRINT"; then
		echo "$ansible_recommended"
		exit 0
	fi

	if test ! -f "${VAULT_FILE}.asc"; then
		gpg-connect-agent reloadagent /bye || exit 1

		read -s -p 'Password: ' pass1; echo
		read -s -p 'Confirm password: ' pass2; echo

		if test "$pass1" != "$pass2"; then
			error "utils error: passwords do not match"
		fi

		echo "$pass1" > "$VAULT_FILE"
		gpg --batch --quiet --armor --passphrase-file <(echo "$pass1") --symmetric "$VAULT_FILE" || { rm "$VAULT_FILE"{,.asc}; exit 1; }
		rm "$VAULT_FILE"
	fi

	if test ! -f "$VAULT_SH"; then
		cat <<EOF >"$VAULT_SH"
#!$(which env) -S bash

gpg --quiet --decrypt "${VAULT_FILE}.asc"
EOF
		chmod u+x "$VAULT_SH"
	fi

	if test ! -f "$BASE_DIR/ansible/connectionpass.sh"; then
		mkdir -p "$BASE_DIR/ansible" || error "$SCRIPT: error: cannot create folder '$BASE_DIR/ansible'"
		cat <<EOF >"$BASE_DIR/ansible/connectionpass.sh"
#!$(which env) -S bash

ansible-vault view $BASE_DIR/credentials/$LOGIN_NAME | head -1
EOF
		chmod u+x "$BASE_DIR/ansible/connectionpass.sh"
	fi

	if test ! -f "$BASE_DIR/ansible/becomepass.sh"; then
		mkdir -p "$BASE_DIR/ansible" || error "$SCRIPT: error: cannot create folder '$BASE_DIR/ansible'"
		cat <<EOF >"$BASE_DIR/ansible/becomepass.sh"
#!$(which env) -S bash

ansible-vault view $BASE_DIR/credentials/$LOGIN_NAME | head -1
EOF
		chmod u+x "$BASE_DIR/ansible/becomepass.sh"
	fi

	if test -n "$CONFIG" -a ! -f "$BASE_DIR/credentials/$LOGIN_NAME"; then
		vault_edit "$BASE_DIR/credentials/$LOGIN_NAME"
	fi
}

source_lib() {
	file="$1"
	section="$(tr a-z A-Z <<< "$2")"
	test -f "$file" || error "utils error: file doesn't exists ($file)"
	grep -q "^# $section SECTION$" "$file" || error "utils error: section '$section' doesn't exists in file '$file'"
	source <(cat "$file" | sed -zE "s/.*\n(# $section SECTION\n)/\1/;s/(\n# END OF $section\n).*/\1/")
}
# END OF UTILS

# PARSER SECTION
parseopts() {
	if [[ $# == 0 ]]; then
		cat <<EOF >&2
usage:
  parseopts [OPTIONS] -- [ARGUMENTS]

  the option syntax it's as follows:
    short: [a-zA-Z0-9]=VARNAME
    long: -OPTION | -OPTION=VARNAME

  short options needs a var to be specified, while long options will take the option as a varname
  long options need to start with '-' and will be converted to lowercase
  varnames will be converted to upper case and '-' to '_', a varname must start with a letter or underscore

  after the option and before the '=' a character can be specified to indicate how to parse said option
        if empty it will be a boolean option, bool and count vars can be abbreviated like this '-zn'
    :   takes an argument
    ::  optionally takes an argument
    +   takes an array of arguments
    *   optionally takes an array of arguments
    :+  can be specified multiple times, will add to the array VARNAME
    :*  counted var, increases VARNAME count every time it is specified (starts at 0)

opts usage:
  short: -w5, -w 5
  long: --timeout=5, --timeout 5
  if the option is of type + or * and is in the form -w5 or --timeout=5 it will only accept the first argument

global variables:
  _EXEC_NAME name of the current program to use when printing error
  _ALLOW_HYPHEN_VALUES self explanatory, if an argument is in the form -o-asd or --opt=-asd the value will be accepted whether this var is set or not
  _ARGV (output) is an array with the all arguments before parsing
  _ARGS (output) is an array with the remaining arguments after parsing

example:
  source parseopts
  parseopts -dir: f+=files v:\\*=verbosity h=help -help -version=ver -- "\$@" || exit $?
  set -- "\${_ARGS[@]}"
EOF
		return 1
	fi

	_EXEC_NAME="${_EXEC_NAME:-$(basename "$0")}"
	_ARGS=()

	_parseopts_error() {
		unset -f _parseopts_error _parseopts_check
		echo "$_EXEC_NAME: parseopts error:" "$@" >&2
		return 1
	}

	local \
		short_opts short_opts_parse short_opts_var \
		short_copts short_copts_parse short_copts_var \
		long_opts long_opts_parse long_opts_var \
		tmp i aux val opt arg var par cnt type flag

	# Parse options until '--'
	for arg in "$@"; do
		case "$arg" in
			--)
				flag=true
				shift
				break
				;;
			-*)
				opt="-${arg%%[:=+*]*}"
				opt="${opt,,}"
				if [[ -n "${opt//[a-zA-Z0-9\-]}" || "${opt//--[a-zA-Z0-9]/_}" != _* ]]; then
					_parseopts_error "long opt $opt in invalid, needs to follow the regex ^--[a-zA-Z0-9](-?[a-zA-Z0-9])*\$"
					return $?
				elif [[ "$opt" == --*--* ]]; then
					_parseopts_error "long opt $opt has '--' inside it's name"
					return $?
				elif [[ "${long_opts[*]} " == *"$opt "* ]]; then
					_parseopts_error "long opt $opt already exists"
					return $?
				fi
				par="${arg[@]:$((${#opt}-1))}"
				if [[ "$par" == *=* ]]; then
					var="${par##*=}"
					var="${var//-/_}"
					var="${var^^}"
					par="${par%%=*}"
				else
					var="${opt[@]:2}"
					var="${var//-/_}"
					var="${var^^}"
				fi
				type=long
				long_opts+=("$opt")
				long_opts_var+=("$var")
				long_opts_parse+=("$par")
				;;
			*)
				opt="-${arg[@]:0:1}"
				if [[ -n "${opt##-[a-zA-Z0-9]}" ]]; then
					_parseopts_error "short opt $opt is invalid, needs to folow the regex ^-[a-zA-Z0-9]\$"
					return $?
				elif [[ "$arg" != *=* ]]; then
					_parseopts_error "short opt $opt doesn't have var"
					return $?
				elif [[ "${short_opts[*]} ${short_copts[*]}" == *"$opt"* ]]; then
					_parseopts_error "short opt $opt already exists"
					return $?
				fi
				var="${arg##*=}"
				var="${var//-/_}"
				var="${var^^}"
				par="${arg[@]:1}"
				par="${par%%=*}"
				type=short
				case "$par" in
					""|:\*)
						short_copts+=("$opt")
						short_copts_var+=("$var")
						short_copts_parse+=("$par")
						;;
					*)
						short_opts+=("$opt")
						short_opts_var+=("$var")
						short_opts_parse+=("$par")
						;;
				esac
				;;
		esac

		if [[ -z "$var" ]]; then
			_parseopts_error "$type opt $opt variable is empty"
			return $?
		elif [[ -n "${var//[a-zA-Z0-9_]}" ]]; then
			_parseopts_error "$type opt $opt variable name is invalid ($var), needs to folow the regex [a-zA-Z0-9_]"
			return $?
		elif [[ "${var##[a-zA-Z_]}" == "$var" ]]; then
			_parseopts_error "$type opt $opt variable doesn't start with a letter or underscore ($var)"
			return $?
		fi

		case "$par" in
			""|:|::|:+|\*|\+)
				unset "$var"
				;;
			:\*)
				eval "$var=0"
				;;
			*)
				_parseopts_error "$type opt $opt parsing is invalid ($par), expected \"\", :, ::, :*, :+, *, +"
				return $?
				;;
		esac
		shift
	done

	if [[ -z "$flag" ]]; then
		_parseopts_error "no end of parsing found, expected '--' to stop parsing options and start parsing arguments"
		return $?
	fi
	_ARGV=("$@")

	_parseopts_check() {
		local check="$1"
		case "$check" in
			--*) [[ "${long_opts[*]} " == *"${check%%=*} "* ]] && return 0 ;;
			-*) [[ "${short_opts[*]} ${short_copts[*]}" == *"${check[@]:0:2}"* ]] && return 0 ;;
		esac
		return 1
	}

	# Loop over remaining arguments
	while [[ "$#" -gt 0 ]]; do
		unset opt
		arg="$1"

		# Check if argument is an option
		case "$arg" in
			--)
				shift
				_ARGS+=("$@")
				break
				;;
			--*)
				tmp="${arg%%=*}"
				for i in "${!long_opts[@]}"; do
					[[ "$tmp" == "${long_opts[$i]}" ]] || continue
					opt="${long_opts[$i]}"
					var="${long_opts_var[$i]}"
					par="${long_opts_parse[$i]}"
					cnt=$((${#tmp}+1))
					shift
					break
				done
				;;
			-*)
				if [[ "${short_copts[*]}" == *"-${arg[@]:1:1}"* ]]; then
					tmp="${arg[@]:1}"
					while [[ "${#tmp}" -gt 0 ]]; do
						aux="${short_copts[*]} "
						eval "aux=\"\${aux%%-${tmp[@]:0:1}*}\""
						i=$((${#aux}/3))
						if [[ "${#short_copts[@]}" -eq "$i" ]]; then
							_parseopts_error "unrecognized option $arg"
							return $?
						fi
						case "${short_copts_parse[$i]}" in
							"")
								eval "${short_copts_var[$i]}=true"
								;;
							:\*)
								eval "${short_copts_var[$i]}=\$((${short_copts_var[$i]}+1))"
								;;
							*)
								_parseopts_error "expected parse type \"\" or :*, found ${short_copts_parse[$i]}"
								return $?
								;;
						esac
						tmp="${tmp[@]:1}"
					done
					shift
					continue
				fi
				tmp="${arg[@]:0:2}"
				aux="${short_opts[*]} "
				eval "aux=\"\${aux%%$tmp*}\""
				i=$((${#aux}/3))
				if [[ "$i" -lt "${#short_opts[@]}" ]]; then
					opt="${short_opts[$i]}"
					var="${short_opts_var[$i]}"
					par="${short_opts_parse[$i]}"
					cnt=2
					shift
				fi
				;;
			*)
				_ARGS+=("$arg")
				shift
				continue
				;;
		esac

		if [[ -z "${opt+x}" ]]; then
			if [[ -n "$_ALLOW_HYPHEN_VALUES" ]]; then
				_ARGS+=("$arg")
				shift
				continue
			else
				_parseopts_error "unrecognized option $arg"
				return $?
			fi
		fi

		# Parse option
		case "$par" in
			"")
				if [[ "${#tmp}" -lt "${#arg}" ]]; then
					_parseopts_error "unrecognized option $arg"
					return $?
				else
					eval "$var=true"
				fi
				;;
			:)
				if [[ "${#tmp}" -lt "${#arg}" ]]; then
					eval "$var=\"\${arg[@]:$cnt}\""
				elif [[ "$#" -lt "1" ]]; then
					_parseopts_error "no argument was given to flag $opt"
					return $?
				else
					if [[ "$1" != -* ]] || { [[ -n "$_ALLOW_HYPHEN_VALUES" ]] && ! _parseopts_check "$1"; }; then
						eval "$var=\"\$1\""
						shift
					else
						_parseopts_error "no argument was given to flag $opt"
						return $?
					fi
				fi
				;;
			::)
				if [[ "${#tmp}" -lt "${#arg}" ]]; then
					eval "$var=\"\${arg[@]:$cnt}\""
				elif [[ "$#" -lt "1" ]]; then
					eval "$var="
				elif [[ "$1" != -* ]] || { [[ -n "$_ALLOW_HYPHEN_VALUES" ]] && ! _parseopts_check "$1"; }; then
					eval "$var=\"\$1\""
					shift
				fi
				;;
			:\*)
				if [[ "${#tmp}" -lt "${#arg}" ]]; then
					_parseopts_error "unrecognized option $arg"
					return $?
				else
					eval "$var=\$(($var+1))"
				fi
				;;
			:+)
				if [[ "${#tmp}" -lt "${#arg}" ]]; then
					eval "$var+=(\"\${arg[@]:$cnt}\")"
				elif [[ "$#" -lt "1" ]]; then
					_parseopts_error "no argument was given to flag $opt"
					return $?
				else
					if [[ "$1" != -* ]] || { [[ -n "$_ALLOW_HYPHEN_VALUES" ]] && ! _parseopts_check "$1"; }; then
						eval "$var+=(\"\$1\")"
						shift
					else
						_parseopts_error "no argument was given to flag $opt"
						return $?
					fi
				fi
				;;
			\*|\+)
				if [[ "${#tmp}" -lt "${#arg}" ]]; then
					eval "$var=(\"\${arg[@]:$cnt}\")"
				else
					eval "$var=()"
					if [[ -n "$_ALLOW_HYPHEN_VALUES" ]]; then
						while [[ "$#" -gt 0  ]]; do
							[[ "$1" == -* ]] && _parseopts_check "$1" && break
							eval "$var+=(\"\$1\")"
							shift
						done
					else
						while [[ "$#" -gt 0  ]]; do
							[[ "$1" != -* ]] || break
							eval "$var+=(\"\$1\")"
							shift
						done
					fi
					if [[ "$par" = + ]] && eval "[[ \"\${#$var[@]}\" == 0 ]]"; then
						_parseopts_error "no argument was given to flag $opt"
						return $?
					fi
				fi
				;;
			*)
				_parseopts_error "unrecognized parse type $par"
				return $?
				;;
		esac
	done

	unset -f _parseopts_error _parseopts_check
}
# END OF PARSER

main "$@"
