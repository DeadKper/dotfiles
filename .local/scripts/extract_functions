#!/bin/fish

if test (count $argv) -lt 2
	echo "usage: $(basename (status -f)) scheme output-folder"
	return 1
end

set -l data (rg -ni '^\s*create (or replace )?function' $argv[1] | sd ':.*$' '')
set -l size (count $data)
set -l starts
set -l count 0

if not test -d "$argv[2]"
	mkdir "$argv[2]"
end

for line in $data
	set -l start (math $line - 1)
	while sed -n ''$start','$start'p;'(math $start + 1)'q' $argv[1] | rg -q '^--|^\s*$'
		set start (math $start - 1)
	end
	set start (math $start + 1)
	while sed -n ''$start','$start'p;'(math $start + 1)'q' $argv[1] | rg -q '^\s*$'
		set start (math $start + 1)
	end

	set -a starts "$start"
	set count (math $count + 1)

	if test (math $count % 100) -eq 0
		printf '%s: %s%s\n' parsed (math $count / $size x 100) %
	end
end

set -l count 0
set -l size2 (math (count $starts) - 1)

for i in (seq (math $size2 - 1))
	set -l start $starts[$i]
	set -l name (sed -n ''$data[$i]','$data[$i]'p;'(math $data[$i] + 1)'q' $argv[1] \
			| sd -f i '^\s*create (or replace )?function (public\.)?([^(]+)(\([^)]*\)).*' '$3\n$4')
	set -l end (math $starts[(math $i + 1)] - 1)

	while sed -n ''$end','$end'p;'(math $end + 1)'q' $argv[1] | rg -q '^\s*$'
		set end (math $end - 1)
	end

	if test -f "$argv[2]/$name[1].sql"
		set -f output "$argv[2]/$name[1]$name[2].sql"
	else
		set -f output "$argv[2]/$name[1].sql"
	end

	sed -n ''$start','$end'p;'(math $end + 1)'q' $argv[1] > "$output"
	set count (math $count + 1)

	if test (math $count % 100) -eq 0
		printf '%s: %s%s\n' printed (math $count / (math $size2 - 1) x 100) %
	end
end

printf '\nnot done = %s:%s\n' $data[$size] (sed -n ''$data[$size]','$data[$size]'p;'(math $data[$size] + 1)'q' $argv[1])
